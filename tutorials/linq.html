<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>linq.scala</title>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-39122235-2', 'scala-lms.github.io');
      ga('send', 'pageview');

    </script>

    <!-- Bootstrap core CSS -->
    <link href="../bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <script src="../bootstrap/assets/js/ie-emulation-modes-warning.js"></script>

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../bootstrap/assets/js/ie10-viewport-bug-workaround.js"></script>

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Custom styles for this template -->
    <!-- <link href="../bootstrap/carousel.css" rel="stylesheet"> -->

    <!-- font awesome -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">


    <style type="text/css">
@import url(../stylesheets/pygment_trac.css);
/* head fancy: Lobster, Pacifico */
/* head serif: Arvo, Bitter, Podkova, Roboto Slab */
/* dense bold: Squada One, Oswald; */
@import url(https://fonts.googleapis.com/css?family=Arvo:400,700);
@import url(https://fonts.googleapis.com/css?family=Bitter:400,700);
@import url(https://fonts.googleapis.com/css?family=Podkova:400,700);
@import url(https://fonts.googleapis.com/css?family=Roboto+Slab:400,700);
body {
  /*line-height: 1.7;*/
  /*font-family: 'Myriad Pro', Calibri, Helvetica, Arial, sans-serif;*/
  font-family: 'Helvetica Neue';
  /*font-size: 15pt;*/
  color: rgb(41,41,41);
}

h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6 {
  font-family: 'Roboto Slab';
  font-weight: 700;
}


.container h1,h2 {
  border-bottom: 1px solid #e5e5e5;
/*  margin-bottom: 1em;
  margin-top: 2em;*/
}




.jumbotron {
  background: transparent;
}

/* Space out content a bit */
/*body {
  padding-top: 20px;
  padding-bottom: 20px;
}*/

/* Everything but the jumbotron gets side spacing for mobile first views */
.header,
.marketing,
.footer {
  padding-right: 15px;
  padding-left: 15px;
}

/* Custom page header */
.header {
  border-bottom: 1px solid #e5e5e5;
}
/* Make the masthead heading the same height as the navigation */
.header h3 {
  padding-bottom: 19px;
  margin-top: 0;
  margin-bottom: 0;
  line-height: 40px;
}

/* Custom page footer */
.footer {
  padding-top: 19px;
  color: #777;
  border-top: 1px solid #e5e5e5;
}

/* Customize container */
@media (min-width: 768px) {
  .jumbotron .container {
    max-width: 730px;
  }
  .container {
    max-width: 730px;
  }
}
.container-narrow > hr {
  margin: 30px 0;
}

/* Main marketing message and sign up button */
.jumbotron {
  text-align: center;
  border-bottom: 1px solid #e5e5e5;
}
.jumbotron .btn {
  padding: 14px 24px;
  font-size: 21px;
}

/* Supporting marketing content */
.marketing {
  margin: 40px 0;
}
.marketing p + h4 {
  margin-top: 28px;
}

/* Responsive: Portrait tablets and up */
@media screen and (min-width: 768px) {
  /* Remove the padding we set earlier */
  .header,
  .marketing,
  .footer {
    padding-right: 0;
    padding-left: 0;
  }
  /* Space out the masthead */
  .header {
    margin-bottom: 30px;
  }
  /* Remove the bottom border on the jumbotron for visual effect */
  .jumbotron {
    border-bottom: 1px solid #e5e5e5;
  }
}


        #jump_to, #jump_page, #jump_toc {
            background: white;
            -webkit-box-shadow: 0 0 25px #777; -moz-box-shadow: 0 0 25px #777;
            -webkit-border-bottom-left-radius: 5px; -moz-border-radius-bottomleft: 5px;
            font: 10px Arial;
            text-transform: uppercase;
            cursor: pointer;
            text-align: right;
        }
        #jump_to, #jump_wrapper {
            position: fixed;
            right: 0; top: 0;
            padding: 5px 10px;
        }
        #jump_wrapper {
            padding: 0;
            display: none;
        }
        #jump_to:hover #jump_wrapper {
            display: block;
        }
        #jump_page {
            padding: 5px 0 3px;
            margin: 0 0 25px 25px;
        }
        #jump_page .source {
            display: block;
            padding: 5px 10px;
            text-decoration: none;
            border-top: 1px solid #eee;
        }
        #jump_page .source:hover {
            background: #f5f5ff;
        }
        #jump_page .source:first-child {
        }


        #jump_toc {
            padding: 5px 0 3px;
            margin: 0 0 25px 25px;
        }
        #jump_toc li {
            display: block;
            padding: 5px 10px;
            text-decoration: none;
            border-top: 1px solid #eee;
        }
        #jump_toc li:hover {
            background: #f5f5ff;
        }
        #jump_toc li:first-child {
        }



        table td {
            border: 0;
            outline: 0;
        }
        td.docs, th.docs {
            min-width: 575px;
            /*max-width: 450px;
            min-width: 450px;
            min-height: 5px;*/
            padding: 10px 25px 1px 50px;
            /*overflow-x: hidden;*
            vertical-align: top;
            text-align: left;*/
        }
        .docs pre {
            margin: 15px 0 15px;
            padding-left: 15px;
        }
        .docs p tt, .docs p code, .doc code {
            background: #f8f8ff;
            border: 1px solid #dedede;
            font-size: 12px;
            padding: 0 0.2em;
        }
        .pilwrap {
            position: relative;
        }
        .pilcrow {
            font: 12px Arial;
            text-decoration: none;
            color: #454545;
            position: absolute;
            top: 3px; left: -20px;
            padding: 1px 2px;
            opacity: 0;
            -webkit-transition: opacity 0.2s linear;
        }
        td.docs:hover .pilcrow {
            opacity: 1;
        }
        pre {
            border: none;
            /*width: 100%;*/
            vertical-align: top;
            background: #f5f5ff;
            /*border-left: 1px solid #e5e5ee;*/
        }
        pre, tt, code {
            font-size: 12px; line-height: 18px;
            font-family: Menlo, Monaco, Consolas, "Lucida Console", monospace;
        }

        /*---------------------- Prettify Syntax Highlighting -----------------------------*/
        .str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun{color:#660}.pln{color:#000}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec{color:#606}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}@media print{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun{color:#440}.pln{color:#000}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}

        table.doc { margin-bottom: 20px; }
        td.doc { border-bottom: 1px dashed #708090; }
        td.param { font-weight: bold; }
        td.return { font-weight: bold; text-decoration: underline; }
    </style>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/r224/prettify.js" type="text/javascript"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/trunk/src/lang-scala.js" type="text/javascript"></script>
</head>

<body onload="prettyPrint()">
        <div class="navbar navbar-default navbar-static-top" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="index.html">LMS</a>
            </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">
                <li><a href="../index.html"><span class="glyphicon glyphicon-home"></span> Home</a></li>
                <li class="active"><a href="../tutorials/index.html"><i class="fa fa-book"></i> Documentation</a></li>
                <li><a href="../resources.html">Resources</a></li>
                <li><a href="../publications.html">Publications</a></li>
                <li><a href="../community.html">Community</a></li>
                <!--<li><a href="community.html">Community</a></li>-->
                <!--<li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <span class="caret"></span></a>
                  <ul class="dropdown-menu" role="menu">
                    <li><a href="#">Action</a></li>
                    <li><a href="#">Another action</a></li>
                    <li><a href="#">Something else here</a></li>
                    <li class="divider"></li>
                    <li class="dropdown-header">Nav header</li>
                    <li><a href="#">Separated link</a></li>
                    <li><a href="#">One more separated link</a></li>
                  </ul>
                </li>-->
              </ul>
            </div>
          </div>
        </div>

    <div class="container">
    <div id="background"></div>
    <div id="jump_to">
        linq.scala // Jump To &hellip;
        <div id="jump_wrapper">
            <div id="jump_toc"></div>
            <div id="jump_page">
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/01_overview.html">
                    01_overview.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/02_basics.html">
                    02_basics.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/03_compiler.html">
                    03_compiler.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/04_atwork.html">
                    04_atwork.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/ack.html">
                    ack.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/automata.html">
                    automata.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/dslapi.html">
                    dslapi.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/dynvar.html">
                    dynvar.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/fft.html">
                    fft.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/index.html">
                    index.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/linq.html">
                    linq.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/query.html">
                    query.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/query_live.html">
                    query_live.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/query_live_steps.html">
                    query_live_steps.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/query_optc.html">
                    query_optc.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/query_staged.html">
                    query_staged.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/query_staged0.html">
                    query_staged0.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/query_unstaged.html">
                    query_unstaged.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/regex.html">
                    regex.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/scanner.html">
                    scanner.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/scannerlib.html">
                    scannerlib.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/shonan-live.html">
                    shonan-live.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/shonan.html">
                    shonan.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/start.html">
                    start.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/stencil.html">
                    stencil.html
                </a>
                
                <a class="source" href="http://scala-lms.github.io/summer-of-lms-2014/tutorials/utils.html">
                    utils.html
                </a>
                
            </div>
        </div>
    </div>

    <ol class="breadcrumb">
      <li><a href="../">LMS</a></li>
      <li><a href="index.html">Tutorials</a></li>
      <li class="active">linq.scala</li>
    </ol>


    <!--<div id="tableofcontents" style="position: fixed; right: 0; top: 0; margin-top:75px; margin-right:20px; width: 150px;">-->
    <!-- tbd whether it should be here ?? -->

        
            <div class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_0">&#182;</a>
                </div>
                <h1>Language Integrated Queries with Normalization</h1>
<p>This tutorial is an implementation of a normalization procedure for language integrated queries (LINQ) described by Cheney, Lindley and Wadler.</p>
<p>For details, see:</p>
<ul>
<li>The Essence of LINQ (<a href="http://homepages.inf.ed.ac.uk/slindley/papers/essence-of-linq-draft-december2012.pdf">PDF</a>).
<br  />James Cheney, Sam Lindley, Philip Wadler</li>
</ul>
<p>Outline:</p>
<div id="tableofcontents"></div>

            </div>
            <div class="code">
                <pre><code class='prettyprint lang-scala'>package scala.lms.tutorial

import scala.virtualization.lms.common._
import scala.reflect.SourceContext

</code></pre>
            </div>
        
            <div class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_1">&#182;</a>
                </div>
                <p>We first implement a pure, non-staged library version as a baseline.</p>

            </div>
            <div class="code">
                <pre><code class='prettyprint lang-scala'>trait Shallow extends Util {
  
  // people db schema

  case class Person(name: String, age: Int) extends Record
  case class Couple(her: String, him: String) extends Record
  case class PeopleDB(people: List[Person], couples: List[Couple]) extends Record

  val db = PeopleDB(
    people = List(
      Person(&quot;Alex&quot;, 60),
      Person(&quot;Bert&quot;, 55),
      Person(&quot;Cora&quot;, 33),
      Person(&quot;Drew&quot;, 31),
      Person(&quot;Edna&quot;, 21),
      Person(&quot;Fred&quot;, 60)),
    couples = List(
      Couple(&quot;Alex&quot;, &quot;Bert&quot;),
      Couple(&quot;Cora&quot;, &quot;Drew&quot;)))

  // 2.1 Comprehensions and queries / 2.2 Query via quotation

  val differences: List[{ val name: String; val diff: Int }] =
    for {
      c &lt;- db.couples
      w &lt;- db.people
      m &lt;- db.people
      if c.her == w.name &amp;&amp; c.him == m.name &amp;&amp; w.age &gt; m.age
    } yield new Record { 
      val name = w.name
      val diff = w.age - m.age
    }

  // 2.3 Abstracting over values

  type Names = List[{ val name: String}]
  def range(a: Int, b: Int): Names =
    for {
      w &lt;- db.people
      if a &lt;= w.age &amp;&amp; w.age &lt; b
    } yield new Record {
      val name = w.name
    }

  val thirtySomethings = range(30,40)

  // 2.4 Abstracting over a predicate

  def satisfies(p: Int =&gt; Boolean): Names = 
    for {
      w &lt;- db.people
      if p(w.age)
    } yield new Record {
      val name = w.name
    }

  val thirtySomethings2 = satisfies(x =&gt; 30 &lt;= x &amp;&amp; x &lt; 40)
  val evenAge = satisfies(_ % 2 == 0)

  // 2.5 Composing queries

  def ageFromName(s: String): List[Int] =
    for {
      u &lt;- db.people
      if u.name == s
    } yield u.age


  def rangeFromNames(s: String, t: String): Names =
    for {
      a &lt;- ageFromName(s)
      b &lt;- ageFromName(t)
      r &lt;- range(a,b)
    } yield r

  val rangeBertEdna = rangeFromNames(&quot;Edna&quot;, &quot;Bert&quot;)

  // 2.6 Dynamically generated queries

  abstract class Predicate
  case class Above(x: Int) extends Predicate
  case class Below(x: Int) extends Predicate
  case class And(x: Predicate, y: Predicate) extends Predicate
  case class Or(x: Predicate, y: Predicate) extends Predicate
  case class Not(x: Predicate) extends Predicate

  val t0: Predicate = And(Above(30), Below(40))
  val t1: Predicate = Not(Or(Below(30), Above(40)))

  def P(t: Predicate)(x: Int): Boolean = t match {
    case Above(a) =&gt; a &lt;= x
    case Below(a) =&gt; x &lt; a
    case And(t, u) =&gt; P(t)(x) &amp;&amp; P(u)(x)
    case Or(t, u) =&gt; P(t)(x) || P(u)(x)
    case Not(t)=&gt; !P(t)(x)
  }

  val thirtySomethings3 = satisfies(P(t0))
  val thirtySomethings4 = satisfies(P(t1))

  // 3 nesting

  // corporate schema

  type Org = List[{
    val departments: List[{val dpt: String}]
    val employees: List[{val dpt: String; val emp: String}]
    val tasks: List[{val emp: String; val tsk: String}]
  }]

  val org = new Record {
    val departments = List(
      new Record { val dpt = &quot;Product&quot;},
      new Record { val dpt = &quot;Quality&quot;},
      new Record { val dpt = &quot;Research&quot;},
      new Record { val dpt = &quot;Sales&quot;})
    val employees = List(
      new Record { val dpt = &quot;Product&quot;; val emp = &quot;Alex&quot;},
      new Record { val dpt = &quot;Product&quot;; val emp = &quot;Bert&quot;},
      new Record { val dpt = &quot;Research&quot;; val emp = &quot;Cora&quot;}, 
      new Record { val dpt = &quot;Research&quot;; val emp = &quot;Drew&quot;}, 
      new Record { val dpt = &quot;Research&quot;; val emp = &quot;Edna&quot;}, 
      new Record { val dpt = &quot;Sales&quot;; val emp = &quot;Fred&quot;})
    val tasks = List(
      new Record { val emp = &quot;Alex&quot;; val tsk = &quot;build&quot;},
      new Record { val emp = &quot;Bert&quot;; val tsk = &quot;build&quot;}, 
      new Record { val emp = &quot;Cora&quot;; val tsk = &quot;abstract&quot;},
      new Record { val emp = &quot;Cora&quot;; val tsk = &quot;build&quot;},
      new Record { val emp = &quot;Cora&quot;; val tsk = &quot;design&quot;},
      new Record { val emp = &quot;Drew&quot;; val tsk = &quot;abstract&quot;},
      new Record { val emp = &quot;Drew&quot;; val tsk = &quot;design&quot;},
      new Record { val emp = &quot;Edna&quot;; val tsk = &quot;abstract&quot;},
      new Record { val emp = &quot;Edna&quot;; val tsk = &quot;call&quot;},
      new Record { val emp = &quot;Edna&quot;; val tsk = &quot;design&quot;},
      new Record { val emp = &quot;Fred&quot;; val tsk = &quot;call&quot;})
  }

  def exists[T](xs: List[T]) = xs.nonEmpty // helper method

  def expertise(u: String): List[{ val dpt: String }] =
    for {
      d &lt;- org.departments
      if !exists(
        for {
          e &lt;- org.employees
          if d.dpt == e.dpt &amp;&amp; !exists(
            for {
              t &lt;- org.tasks
              if e.emp == t.emp &amp;&amp; t.tsk == u 
            } yield new Record {})
        } yield new Record {})
    } yield new Record { val dpt = d.dpt }

  val departmentsFullOfAbstracters = expertise(&quot;abstract&quot;)

  // 3.1 Nested structures

  type NestedOrg = List[{
    val dpt: String
    val employees: List[{
      val emp: String
      val tasks: List[String]
    }]
  }]

  val nestedOrg: NestedOrg =
    for { 
      d &lt;- org.departments
    } yield new Record {
      val dpt = d.dpt
      val employees = for {
        e &lt;- org.employees
        if d.dpt == e.dpt
      } yield new Record {
        val emp = e.emp 
        val tasks = for {
          t &lt;- org.tasks 
          if e.emp == t.emp
        } yield t.tsk
      }
    }

  // 3.2 Higher-order queries

  def any[A](xs: List[A])(p: A =&gt; Boolean): Boolean =
    exists(for (x &lt;- xs if p(x)) yield new Record { })

  def all[A](xs: List[A])(p: A =&gt; Boolean): Boolean =
    !any(xs)(x =&gt; !p(x))

  def contains[A](xs: List[A], u: A): Boolean =
    any(xs)(x =&gt; x == u)

  def expertise2(u: String): List[{ val dpt: String }] =
    for {
      d &lt;- nestedOrg
      if all(d.employees)(e =&gt; contains(e.tasks, u)) 
    } yield new Record { val dpt = d.dpt }

  val departmentsFullOfAbstracters2 = expertise2(&quot;abstract&quot;)


  // 4 From XPath to SQl

  /*
  +----+--------+------+-----+------+
  | id | parent | name | pre | post |
  +----+--------+------+-----+------+
  |  0 |   -1   | #doc |  0  |  13  |
  |  1 |    0   |   a  |  1  |  12  |
  |  2 |    1   |   b  |  2  |   5  |
  |  3 |    2   |   c  |  3  |   4  |
  |  4 |    1   |   d  |  6  |  11  |
  |  5 |    4   |   e  |  7  |   8  |
  |  6 |    4   |   f  |  9  |  10  |
  +----+--------+------+-----+------+

  case class Node(
    val id: Int,
    val parent: Int,
    val name: String,
    val pre: Int,
    val post: Int 
  ) extends Record

  val db_xml = List(
    Node(0, -1, &quot;#doc&quot;, 0, 13),
    Node(1,  0, &quot;a&quot;,    1, 12),
    Node(2,  1, &quot;b&quot;,    2,  5),
    Node(3,  2, &quot;c&quot;,    3,  4),
    Node(4,  1, &quot;d&quot;,    6, 11),
    Node(5,  4, &quot;e&quot;,    7,  8),
    Node(6,  4, &quot;f&quot;,    9, 10))


  abstract class Axis
  case object Self extends Axis
  case object Child extends Axis
  case object Descendant extends Axis
  case object DescendantOrSelf extends Axis
  case object Following extends Axis
  case object FollowingSibling extends Axis
  case class Rev(x: Axis) extends Axis
 
  def parent = PAxis(Rev(Child))
  def ancestor = PAxis(Rev(Descendant))
  def preceding = PAxis(Rev(Following))

  abstract class Path
  case class PSeq(x: Path, y: Path) extends Path
  case class PAxis(x: Axis) extends Path
  case class NameTest(x: String) extends Path
  case class Filter(x: Path) extends Path

  def axis(ax: Axis)(s: Node, t: Node): Boolean = ax match {
    case Self             =&gt; s.id == t.id
    case Child            =&gt; s.id == t.parent
    case Descendant       =&gt; s.pre &lt; t.pre &amp;&amp; t.post &lt; s.post
    case DescendantOrSelf =&gt; s.pre &lt;= t.pre &amp;&amp; t.post &lt;= s.post
    case Following        =&gt; s.pre &lt; t.pre 
    case FollowingSibling =&gt; s.post &lt; t.pre &amp;&amp; s.parent == t.parent
    case Rev(ax)          =&gt; axis(ax)(t, s)
  }

  // code in paper:
  // | Rev(axis) → &lt;@ fun(s, t) → (%axis(ax))(t, s) @&gt; 
  //       ^^^^                     ^^^^
  //   should be ax?

  def path(p : Path)(s: Node, u: Node): Boolean = p match {
    case PSeq(p, q) =&gt; 
      any(db_xml)(t =&gt; path(p)(s, t) &amp;&amp; path(q)(t, u))
    case PAxis(ax) =&gt; 
      axis(ax)(s, u)
    case NameTest(name) =&gt;
      s.id == u.id &amp;&amp; s.name == name
    case Filter(p) =&gt; 
      s.id == u.id &amp;&amp; any(db_xml)(t =&gt; path(p)(s, t))
  }

  def xpath(p : Path): List[Int] = for {
    root &lt;- db_xml
    s &lt;- db_xml
    if (root.parent == -1) &amp;&amp; path(p)(root, s)
  } yield s.id


  //  /*/*
  val xp0 = PSeq(PAxis(Child), PAxis(Child))
  //  //*/parent::*
  val xp1 = PSeq(PAxis(Descendant), parent)
  // Q: this produces 0,1,2,4 but the paper says 1,2,4 (?)

  //  //*[following-sibling::d]
  val xp2 = PSeq(PAxis(Descendant), Filter(PSeq(PAxis(FollowingSibling),NameTest(&quot;d&quot;))))
  //  //f[ancestor::*/preceding::b]()
  val xp3 = PSeq(PSeq(PAxis(Descendant), NameTest(&quot;f&quot;)), Filter(PSeq(ancestor,PSeq(preceding, NameTest(&quot;b&quot;)))))

  val xr0 = xpath(xp0)
  val xr1 = xpath(xp1)
  val xr2 = xpath(xp2)
  val xr3 = xpath(xp3)

}


// a staged implementation
trait Staged extends ScalaOpsPkg with LiftPrimitives with LiftString with StructOps {
  
  def database[T:Manifest](s: String): Rep[T]
  //trait Record extends Struct
  implicit def recordToRecordOps2(record: Rep[Record]) = new RecordOps(record.asInstanceOf[Rep[Record]])

  //trait Inner {

  // people db schema

  type Person = Record {
    val name: String
    val age: Int
  }

  type Couple = Record {
    val her: String
    val him: String
  }

  type PeopleDB = Record {
    val people: List[Person]
    val couples: List[Couple]
  }

  //val db = staticData//database[PeopleDB](&quot;PeopleDB&quot;)
  val db = database[PeopleDB](&quot;db&quot;)
  /*PeopleDB(
    people = List(
      Person(&quot;Alex&quot;, 60),
      Person(&quot;Bert&quot;, 55),
      Person(&quot;Cora&quot;, 33),
      Person(&quot;Drew&quot;, 31),
      Person(&quot;Edna&quot;, 21),
      Person(&quot;Fred&quot;, 60)),
    couples = List(
      Couple(&quot;Alex&quot;, &quot;Bert&quot;),

  // 2.1 Comprehensions and queries / 2.2 Query via quotation

  val differences: Rep[List[{ val name: String; val diff: Int }]] =
    for {
      c &lt;- db.couples
      w &lt;- db.people
      m &lt;- db.people
      if c.her == w.name &amp;&amp; c.him == m.name &amp;&amp; w.age &gt; m.age
    } yield new Record { 
      val name = w.name
      val diff = w.age - m.age
    }

  // 2.3 Abstracting over values

  type Names = List[{ val name: String}]
  def range(a: Rep[Int], b: Rep[Int]): Rep[Names] =
    for {
      w &lt;- db.people
      if a &lt;= w.age &amp;&amp; w.age &lt; b
    } yield new Record {
      val name = w.name
    }

  val thirtySomethings = range(30,40)

  // 2.4 Abstracting over a predicate

  def satisfies(p: Rep[Int] =&gt; Rep[Boolean]): Rep[Names] = 
    for {
      w &lt;- db.people
      if p(w.age)
    } yield new Record {
      val name = w.name
    }

  val thirtySomethings2 = satisfies(x =&gt; 30 &lt;= x &amp;&amp; x &lt; 40)
  val evenAge = satisfies(_ % 2 == 0)

  // 2.5 Composing queries

  def ageFromName(s: Rep[String]): Rep[List[Int]] =  // paper has return type 'int' but says 'list of int' in the text (?)
    for {
      u &lt;- db.people
      if u.name == s
    } yield u.age


  def rangeFromNames(s: Rep[String], t: Rep[String]): Rep[Names] =
    for {
      a &lt;- ageFromName(s)
      b &lt;- ageFromName(t)
      r &lt;- range(a,b)
    } yield r

  val rangeBertEdna = rangeFromNames(&quot;Edna&quot;, &quot;Bert&quot;)

  // 2.6 Dynamically generated queries

  abstract class Predicate
  case class Above(x: Int) extends Predicate
  case class Below(x: Int) extends Predicate
  case class And(x: Predicate, y: Predicate) extends Predicate
  case class Or(x: Predicate, y: Predicate) extends Predicate
  case class Not(x: Predicate) extends Predicate

  val t0: Predicate = And(Above(30), Below(40))
  val t1: Predicate = Not(Or(Below(30), Above(40)))

  def P(t: Predicate)(x: Rep[Int]): Rep[Boolean] = t match {
    case Above(a) =&gt; a &lt;= x
    case Below(a) =&gt; x &lt; a
    case And(t, u) =&gt; P(t)(x) &amp;&amp; P(u)(x)
    case Or(t, u) =&gt; P(t)(x) || P(u)(x)
    case Not(t)=&gt; !P(t)(x)
  }

  val thirtySomethings3 = satisfies(P(t0))
  val thirtySomethings4 = satisfies(P(t1))

  // 3 nesting

  // corporate schema

  type Org = Record {
    val departments: List[Record {val dpt: String}]
    val employees: List[Record {val dpt: String; val emp: String}]
    val tasks: List[Record {val emp: String; val tsk: String}]
  }

  val org = database[Org](&quot;org&quot;)

  /*val org = new Record {
    val departments = List(
      new Record { val dpt = &quot;Product&quot;},
      new Record { val dpt = &quot;Quality&quot;},
      new Record { val dpt = &quot;Research&quot;},
      new Record { val dpt = &quot;Sales&quot;})
    val employees = List(
      new Record { val dpt = &quot;Product&quot;; val emp = &quot;Alex&quot;},
      new Record { val dpt = &quot;Product&quot;; val emp = &quot;Bert&quot;},
      new Record { val dpt = &quot;Research&quot;; val emp = &quot;Cora&quot;}, 
      new Record { val dpt = &quot;Research&quot;; val emp = &quot;Drew&quot;}, 
      new Record { val dpt = &quot;Research&quot;; val emp = &quot;Edna&quot;}, 
      new Record { val dpt = &quot;Sales&quot;; val emp = &quot;Fred&quot;})
    val tasks = List(
      new Record { val emp = &quot;Alex&quot;; val tsk = &quot;build&quot;},
      new Record { val emp = &quot;Bert&quot;; val tsk = &quot;build&quot;}, 
      new Record { val emp = &quot;Cora&quot;; val tsk = &quot;abstract&quot;},
      new Record { val emp = &quot;Cora&quot;; val tsk = &quot;build&quot;},
      new Record { val emp = &quot;Cora&quot;; val tsk = &quot;design&quot;},
      new Record { val emp = &quot;Drew&quot;; val tsk = &quot;abstract&quot;},
      new Record { val emp = &quot;Drew&quot;; val tsk = &quot;design&quot;},
      new Record { val emp = &quot;Edna&quot;; val tsk = &quot;abstract&quot;},
      new Record { val emp = &quot;Edna&quot;; val tsk = &quot;call&quot;},
      new Record { val emp = &quot;Edna&quot;; val tsk = &quot;design&quot;},
      new Record { val emp = &quot;Fred&quot;; val tsk = &quot;call&quot;})

  def exists(xs: Rep[List[Record]]) = !xs.isEmpty // helper method

  val empty = new Record { val ignore = () }

  def expertise(u: Rep[String]): Rep[List[Record { val dpt: String }]] =
    for {
      d &lt;- org.departments
      if !exists(
        for {
          e &lt;- org.employees
          if d.dpt == e.dpt &amp;&amp; !exists(
            for {
              t &lt;- org.tasks
              if e.emp == t.emp &amp;&amp; t.tsk == u 
            } yield empty)
        } yield empty )
    } yield new Record { val dpt = d.dpt }

  val departmentsFullOfAbstracters = expertise(&quot;abstract&quot;)

  // 3.1 Nested structures

  type NestedOrg = List[Record {
    val dpt: String
    val employees: List[Record {
      val emp: String
      val tasks: List[String]
    }]
  }]

  val nestedOrg: Rep[NestedOrg] =
    for { 
      d &lt;- org.departments
    } yield {
      val employees1 = for {
        e &lt;- org.employees
        if d.dpt == e.dpt
      } yield new Record {
        val emp = e.emp 
        val tasks = for {
          t &lt;- org.tasks 
          if e.emp == t.emp
        } yield t.tsk
      }
      new Record {
        val dpt = d.dpt
        val employees = employees1
      }
    }

  // 3.2 Higher-order queries

  def any[A:Manifest](xs: Rep[List[A]])(p: Rep[A] =&gt; Rep[Boolean]): Rep[Boolean] =
    exists(for (x &lt;- xs if p(x)) yield empty)

  def all[A:Manifest](xs: Rep[List[A]])(p: Rep[A] =&gt; Rep[Boolean]): Rep[Boolean] =
    !any(xs)(x =&gt; !p(x))

  def contains[A:Manifest](xs: Rep[List[A]], u: Rep[A]): Rep[Boolean] =
    any(xs)(x =&gt; x == u)

  def expertise2(u: Rep[String]): Rep[List[{ val dpt: String }]] =
    for {
      d &lt;- nestedOrg
      if all(d.employees)(e =&gt; contains(e.tasks, u)) 
    } yield new Record { val dpt = d.dpt }

  val departmentsFullOfAbstracters2 = expertise2(&quot;abstract&quot;)


  // 4 From XPath to SQl

  /*
  +----+--------+------+-----+------+
  | id | parent | name | pre | post |
  +----+--------+------+-----+------+
  |  0 |   -1   | #doc |  0  |  13  |
  |  1 |    0   |   a  |  1  |  12  |
  |  2 |    1   |   b  |  2  |   5  |
  |  3 |    2   |   c  |  3  |   4  |
  |  4 |    1   |   d  |  6  |  11  |
  |  5 |    4   |   e  |  7  |   8  |
  |  6 |    4   |   f  |  9  |  10  |
  +----+--------+------+-----+------+

  type Node = Record {
    val id: Int
    val parent: Int
    val name: String
    val pre: Int
    val post: Int 
  }

  val db_xml = database[Record { val nodes: List[Node]}](&quot;xml&quot;).nodes

  /*val db_xml = List(
    Node(0, -1, &quot;#doc&quot;, 0, 13),
    Node(1,  0, &quot;a&quot;,    1, 12),
    Node(2,  1, &quot;b&quot;,    2,  5),
    Node(3,  2, &quot;c&quot;,    3,  4),
    Node(4,  1, &quot;d&quot;,    6, 11),
    Node(5,  4, &quot;e&quot;,    7,  8),


  abstract class Axis
  case object Self extends Axis
  case object Child extends Axis
  case object Descendant extends Axis
  case object DescendantOrSelf extends Axis
  case object Following extends Axis
  case object FollowingSibling extends Axis
  case class Rev(x: Axis) extends Axis
 
  def parent = PAxis(Rev(Child))
  def ancestor = PAxis(Rev(Descendant))
  def preceding = PAxis(Rev(Following))

  abstract class Path
  case class PSeq(x: Path, y: Path) extends Path
  case class PAxis(x: Axis) extends Path
  case class NameTest(x: String) extends Path
  case class Filter(x: Path) extends Path

  def axis(ax: Axis)(s: Rep[Node], t: Rep[Node]): Rep[Boolean] = ax match {
    case Self             =&gt; s.id == t.id
    case Child            =&gt; s.id == t.parent
    case Descendant       =&gt; s.pre &lt; t.pre &amp;&amp; t.post &lt; s.post
    case DescendantOrSelf =&gt; s.pre &lt;= t.pre &amp;&amp; t.post &lt;= s.post
    case Following        =&gt; s.pre &lt; t.pre 
    case FollowingSibling =&gt; s.post &lt; t.pre &amp;&amp; s.parent == t.parent
    case Rev(ax)          =&gt; axis(ax)(t, s)
  }

  // code in paper:
  // | Rev(axis) → &lt;@ fun(s, t) → (%axis(ax))(t, s) @&gt; 
  //       ^^^^                     ^^^^
  //   should be ax?

  def path(p : Path)(s: Rep[Node], u: Rep[Node]): Rep[Boolean] = p match {
    case PSeq(p, q) =&gt; 
      any(db_xml)(t =&gt; path(p)(s, t) &amp;&amp; path(q)(t, u))
    case PAxis(ax) =&gt; 
      axis(ax)(s, u)
    case NameTest(name) =&gt;
      s.id == u.id &amp;&amp; s.name == name
    case Filter(p) =&gt; 
      s.id == u.id &amp;&amp; any(db_xml)(t =&gt; path(p)(s, t))
  }

  def xpath(p : Path): Rep[List[Int]] = for {
    root &lt;- db_xml
    s &lt;- db_xml
    if (root.parent == -1) &amp;&amp; path(p)(root, s)
  } yield s.id


  //  /*/*
  val xp0 = PSeq(PAxis(Child), PAxis(Child))
  //  //*/parent::*
  val xp1 = PSeq(PAxis(Descendant), parent)
  // Q: this produces 0,1,2,4 but the paper says 1,2,4 (?)

  //  //*[following-sibling::d]
  val xp2 = PSeq(PAxis(Descendant), Filter(PSeq(PAxis(FollowingSibling),NameTest(&quot;d&quot;))))
  //  //f[ancestor::*/preceding::b]()
  val xp3 = PSeq(PSeq(PAxis(Descendant), NameTest(&quot;f&quot;)), Filter(PSeq(ancestor,PSeq(preceding, NameTest(&quot;b&quot;)))))

  val xr0 = xpath(xp0)
  val xr1 = xpath(xp1)
  val xr2 = xpath(xp2)
  val xr3 = xpath(xp3)

  //}
}




// internal staged implementation: IR node classes, rewrites for normalization
trait StagedExp extends Staged with ScalaOpsPkgExp with BooleanOpsExpOpt with StructExpOpt {

  // IR node representing database(&quot;name&quot;)
  case class Database[T](s: String) extends Def[T]
  def database[T:Manifest](s: String): Exp[T] = Database[T](s)

  // IR node representing for (x &lt;- l) yield f(x)
  // we store two representations at the same time:
  // (l,f) and (db.tbl, x =&gt; block)
  // both serve different purposes:
  // - the latter is the normalized form, intensional representation,
  //   used for code generation
  // - the former is the input form, extensional representation,
  //   used to perform rewriting in NBE style (&quot;normalization by evaluation&quot;)
  case class DBFor[A:Manifest, B:Manifest](l: Exp[List[A]], f: Exp[A] =&gt; Exp[List[B]], 
    db: String, tbl: String, ff: Fun[A,List[B]]) extends Def[List[B]]


  // some extractor objects to make pattern matching more convenient
  // (these are not strictly necessary)
  object Empty {
    def apply() = List()
    def unapply[A](x:Exp[List[A]]): Boolean = x match {
      case Def(ListNew(xs)) if xs.length == 0 =&gt; true
      case _ =&gt; false
    }
  }

  object Yield {
    def apply[A:Manifest](x:Exp[A]) = List(x)
    def unapply[A](x:Exp[List[A]]): Option[Exp[A]] = x match {
      case Def(ListNew(xs)) if xs.length == 1 =&gt; Some(xs.head)
      case _ =&gt; None
    }
  }

  object IfThen {
    def unapply[A](x:Exp[List[A]]): Option[(Exp[Boolean], Exp[List[A]])] = x match {
      case Def(IfThenElse(c,Block(a),Block(Empty()))) =&gt; Some((c,a))
      case _ =&gt; None
    }
  }

  object For {
    def unapply[B](x:Exp[List[B]]): Option[(Exp[List[Any]], Exp[Any] =&gt; Exp[List[B]])] = x match {
      case Def(DBFor(l,f,d,t,ff)) =&gt; Some((l,f))
      case _ =&gt; None
    }
  }

  object Concat {
    def unapply[A](x:Exp[List[A]]): Option[(Exp[List[A]], Exp[List[A]])] = x match {
      case Def(ListConcat(a,b)) =&gt; Some((a,b))
      case _ =&gt; None
    }
  }


/*
  normalized syntax:

      (SQLquery)      S ::= [] | X | X1@X2
      (collection)    X ::= database(db) | yield Y | if Z then yield Y | for x in database(db).l do X
      (record)        Y ::= x | {l=Z}
      (base)          Z ::= c | x.l | op(X) | exists S

  normalization 1:

                       (fun(x) → R) Q --&gt; R[x:=Q] 
                             {l=Q}.li --&gt; Qi
      
               for x in (yield Q)do R --&gt; R[x:=Q]
      for y in (for x in P do Q) do R --&gt; for x in P do (for y in Q do R)
          for x in (if P then Q) do R --&gt; if P then (for x in Q do R)
                     for x in [] do N --&gt; []
                for x in (P @ Q) do R --&gt; (for x in P do R) @ (for x in Q do R)
                       if true then Q --&gt; Q
                      if false then Q --&gt; []
      
  normalization 2:

                for x in P do (Q @ R) --&gt; (for x in P do Q) @ (for x in P do R)
                     for x in P do [] --&gt; []
                    if P then (Q @ R) --&gt; (if P then Q) @ (if P then R)
                         if P then [] --&gt; []
              if P then (if Q then R) --&gt; if (P &amp;&amp; Q) then R
          if P then (for x in Q do R) --&gt; for x in Q do (if P then R)



  // implement smart constructor for DBFor nodes; perform normalization.
  // note that we map IR nodes to staged code, not directly to other IR nodes.
  def dbfor[A:Manifest,B:Manifest](l: Exp[List[A]], f: Exp[A] =&gt; Exp[List[B]])(implicit pos: SourceContext): Exp[List[B]] = l match {
/*
             for x in (yield Q)do R --&gt; R[x:=Q]
    for y in (for x in P do Q) do R --&gt; for x in P do (for y in Q do R)
        for x in (if P then Q) do R --&gt; if P then (for x in Q do R)
                   for x in [] do N --&gt; []
              for x in (P @ Q) do R --&gt; (for x in P do R) @ (for x in Q do R)
    case Empty()              =&gt; List()
    case Yield(a)             =&gt; f(a)
    case IfThen(c,a)          =&gt; if (c) for (x &lt;- a; y &lt;- f(x)) yield y else List()
    case For(l2,f2)           =&gt; for (x &lt;- l2; y &lt;- f2(x); z &lt;- f(y)) yield z
    case Concat(a,b)          =&gt; a.flatMap(f) ++ b.flatMap(f)
    case (Def(FieldApply(Def(Database(db)), tbl))) =&gt;     
      val ff = reifyFun(f)
      ff.body match {
/*                 for x in P do [] --&gt; []           */
        case Block(Empty())              =&gt; List()
        case _ =&gt;
          // no rewrites match, go ahead and create IR node
          reflectEffect(DBFor(l, f, db, tbl, ff), summarizeEffects(ff.body).star)
      }
    case (Def(ld)) =&gt; 
      // cannot normalize, report error and throw exception
      printerr(&quot;error: cannot normalize for expression&quot;)
      printerr(s&quot;at $l=$ld&quot;)
      printsrc(s&quot;in ${quotePos(fresh.withPos(pos::Nil))}&quot;)
      throw new MatchError(l)
  }


  // override `if (c) a else b` smart constructor to add rewrites
  override def ifThenElse[T:Manifest](cond: Rep[Boolean], thenp: Block[T], elsep: Block[T])(implicit pos: SourceContext) = ((thenp.res,elsep.res) match {
/*
                  if P then (Q @ R) --&gt; (if P then Q) @ (if P then R)
                       if P then [] --&gt; []
            if P then (if Q then R) --&gt; if (P &amp;&amp; Q) then R
        if P then (for x in Q do R) --&gt; for x in Q do (if P then R)
    case (Empty(),Empty())       =&gt; List()
    case (IfThen(c,a),Empty())   =&gt; if (cond &amp;&amp; c) a else List()
    case (For(l,f),Empty())      =&gt; implicit def unsafe[T] = manifest[Any].asInstanceOf[Manifest[T]] // FIXME: get manifest (for result type) from somewhere else
                                    for (x &lt;- l if cond; y &lt;- f(x)) yield y
    case (Concat(a,b),Empty())   =&gt; (if (cond) a else List()) ++ (if (cond) b else List())
    case _                       =&gt; super.ifThenElse(cond,thenp,elsep)
  }).asInstanceOf[Exp[T]]



  // override Rep[List[T]] methods to create For nodes
  override def list_flatMap[A:Manifest,B:Manifest](l: Exp[List[A]], f: Exp[A] =&gt; Exp[List[B]])(implicit pos: SourceContext) = {
    dbfor[A,B](l,f)
  }
  override def list_map[A:Manifest,B:Manifest](l: Exp[List[A]], f: Exp[A] =&gt; Exp[B])(implicit pos: SourceContext) = {
    list_flatMap[A,B](l, x =&gt; List(f(x)))
  }
  override def list_filter[A : Manifest](l: Exp[List[A]], f: Exp[A] =&gt; Exp[Boolean])(implicit pos: SourceContext) = {
    list_flatMap[A,A](l, x =&gt; if (f(x)) List(x) else List())
  }
  // wrap for bodies as function objects
  case class Fun[A,B](arg: Sym[A], body: Block[B])
  def reifyFun[A:Manifest,B:Manifest](f: Rep[A] =&gt; Rep[B]) = {
    val x = fresh[A]; Fun(x,reifyEffects(f(x)))
  }
}


// code generator for specific IR nodes -- alternative impl would emit SQL
trait ScalaGenStaged extends ScalaCodeGenPkg with ScalaGenStruct {
  val IR: StagedExp
  import IR._

  override def emitFileHeader(): Unit = {
    super.emitFileHeader()
    stream.println(&quot;import scala.lms.tutorial.Schema&quot;)
  }

  override def emitNode(sym: Sym[Any], rhs: Def[Any]) = rhs match {
    case Database(s) =&gt; 
      emitValDef(sym, &quot;Schema.&quot;+s)
    case DBFor(l, f, db, tbl, Fun(x, b)) =&gt; 
      val sdb = &quot;Schema.&quot;+db+&quot;.&quot;+tbl
      stream.println(&quot;val &quot; + quote(sym) + &quot; = &quot; + sdb + &quot;.flatMap { &quot; + quote(x) + &quot; =&gt; &quot;)
      emitBlock(b)
      stream.println(quote(getBlockResult(b)))
      stream.println(&quot;}&quot;)
    case Struct(tag, elems) =&gt;
      emitValDef(sym, &quot;new Schema.Record { &quot; + (for ((n, v) &lt;- elems) yield &quot;val &quot; + n + &quot; = &quot; + quote(v)).mkString(&quot;; &quot;) + &quot; }&quot;)
    case _ =&gt; super.emitNode(sym, rhs)
  }
}

// accessed by generated code
object Schema extends Shallow


// pretty printing for records
trait Util {
  abstract class Record extends Product {
    lazy val elems = {
      val fields = getClass.getDeclaredFields.toList
      for (f &lt;- fields if !f.getName.contains(&quot;$&quot;)) yield {
        f.setAccessible(true)
        (f.getName, f.get(this))
      }
    }
    def canEqual(that: Any) = true
    def productElement(n: Int) = elems(n)
    def productArity = elems.length
    override def productIterator = elems.iterator
    override def toString = elems.map(e =&gt; s&quot;${e._1}:${e._2}&quot;).mkString(&quot;{&quot;,&quot;,&quot;,&quot;}&quot;)
  }
}

abstract class LinqDriver[A:Manifest,B:Manifest] extends DslDriver[A,B] with Staged with StagedExp { q =&gt;
  override val codegen = new DslGen with ScalaGenStaged {
    val IR: q.type = q
  }
  // implement some internal methods for new IR nodes
  override def syms(e: Any): List[Sym[Any]] = e match {
    case DBFor(_, _, _, _, Fun(_, body)) =&gt; syms(body)
    case _ =&gt; super.syms(e)
  }

  override def boundSyms(e: Any): List[Sym[Any]] = e match {
    case DBFor(_, _, _, _, Fun(x, body)) =&gt; x :: effectSyms(body)
    case _ =&gt; super.boundSyms(e)
  }

  override def symsFreq(e: Any): List[(Sym[Any], Double)] = e match {
    // normally we'd want `freqHot` to hoist code out of the loop, 
    // but here we want to keep it inside for clarity
    case DBFor(_, _, _, _, Fun(_, body)) =&gt; freqCold(body) 
    case _ =&gt; super.symsFreq(e)
  }
  override def __ifThenElse[T:Manifest](cond: Rep[Boolean], thenp: =&gt;Rep[T], elsep: =&gt;Rep[T])(implicit pos: SourceContext) = {
    val a = reifyEffectsHere(thenp)
    val b = reifyEffectsHere(elsep)
    val ae = summarizeEffects(a)
    val be = summarizeEffects(b)
    reflectEffectInternal(IfThenElse(cond,a,b), ae orElse be)
  }
}


// test cases
class TestLinq extends TutorialFunSuite {
  val under = &quot;linq-&quot;
  
  test(&quot;rangeFromNames&quot;) {
    val snippet = new LinqDriver[Unit,List[Any]] {
      def snippet(v: Rep[Unit]) = {
          println(&quot;rangeFromNames(\&quot;Edna\&quot;,\&quot;Bert\&quot;):&quot;)
          rangeBertEdna
      }
    }
    assertResult(&quot;List({name:Cora}, {name:Drew}, {name:Edna})&quot;)(snippet.eval().toString)
    check(&quot;rangeFromNames&quot;, snippet.code)
  }

}
</code></pre>
            </div>
        

        <p>
        Comments? Suggestions for improvement? <a class="source" href="https://github.com/scala-lms/tutorials/tree/master/src/test/scala/lms/tutorial/linq.scala">View this file on GitHub</a>.
        </p>

    </div>

    <!-- FOOTER -->
    <div class="footer">
    <div class="container">
      <p class="pull-right"><a href="#">Back to top</a></p>
      <p>&copy; 2011-2015 EPFL and collaborators</p>
    </div>
    </div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="../bootstrap/js/bootstrap.min.js"></script>
    <script src="../bootstrap/assets/js/docs.min.js"></script>
    <script src="../javascripts/toc.min.js"></script>
    <script type="text/javascript">

    $(document).ready(function() {
        $(".container").tableofcontents({
            id: "#tableofcontents"
        });
        $(".container").tableofcontents({
            id: "#jump_toc"
        });
    });

/*
        $('#my-affix').affix({
            offset: {
              top: 100
            , bottom: function () {
                return (this.bottom = $('.footer').outerHeight(true))
              }
            }
        })
*/
    </script>
  </body>
</html>
